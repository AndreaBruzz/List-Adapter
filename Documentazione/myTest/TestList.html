<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="it">
<head>
<!-- Generated by javadoc (11.0.15) on Tue Jun 14 22:24:48 CEST 2022 -->
<title>TestList</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-06-14">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="TestList";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":9,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">myTest</a></div>
<h2 title="Class TestList" class="title">Class TestList</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>myTest.TestList</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">TestList</span>
extends java.lang.Object</pre>
<div class="block">Test class of <a href="../myAdapter/ListAdapter.html" title="class in myAdapter"><code>ListAdapter</code></a> methods
 <p>
 <p>
 Summary: this class tests the functionality of all ListAdapter methods
 <br><br>
 Design test: in this class every method tests a different method of ListAdapter.
 In every method the execution variables changes before calling the tested method in order to test all the possible conditions
 <br><br>
 Description: The ListAdapter class implements HList and HCollection, therefore the HList methods were tested using an HList as object
 The TestList class deals with the testing for all the methods related to the main list and the list iterator, always of the main list.
 For simplicity, the values entered are all Strings because the behaviour of this objects is well known
 <br><br>
 Preconditions:
 <br>A new empty object of type ListAdapter must always be instantiated before each test and also a filled one is created
 <br>All execution variables are never in an uninitialized state (i.e. list = null) unless explicitly desired
 <br>Methods that take as parameters classes that implement HCollection are passed suitable objects for this interface, therefore they do not throw the exception ClassCastException
 <br>All the elements contained in the list are known before the execution in order to allow the verification after the invocation of the tested methods
 <br><br>
 Postconditions: the methods implemented must always modify the list so that the elements contained are exactly those expected starting from their manual insertion
 <br><br>
 Execution record: each tested method is correct if all the tests that verify the correct functioning give positive results. Correct execution of the entire test method can then be considered the execution record
 <br><br>
 Execution variables:
 <br>HList l1 - empty list on which methods common to HCollection and HList are tested
 <br>HList l2 - non-empty list on which methods common to HCollection and HList are tested
 <br>String[] argv - an array of strings used to fill the list in some situations
 <br><br></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../myAdapter/HList.html" title="interface in myAdapter"><code>HList</code></a>, 
<a href="../myAdapter/HIterator.html" title="interface in myAdapter"><code>HIterator</code></a>, 
<a href="../myAdapter/HListIterator.html" title="interface in myAdapter"><code>HListIterator</code></a>, 
<a href="../myAdapter/HCollection.html" title="interface in myAdapter"><code>HCollection</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">TestList</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cleanup()">cleanup</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#iterate(myAdapter.HIterator)">iterate</a></span>&#8203;(<a href="../myAdapter/HIterator.html" title="interface in myAdapter">HIterator</a>&nbsp;iter)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setup()">setup</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testAdd()">testAdd</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#add(java.lang.Object)"><code>ListAdapter.add(Object)</code></a> , <a href="../myAdapter/ListAdapter.html#add(int,java.lang.Object)"><code>ListAdapter.add(int, Object)</code></a> methods</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testAddAll()">testAddAll</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#addAll(myAdapter.HCollection)"><code>ListAdapter.addAll(HCollection)</code></a> , <a href="../myAdapter/ListAdapter.html#addAll(int,myAdapter.HCollection)"><code>ListAdapter.addAll(int, HCollection)</code></a> methods</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testAddAllCriticals()">testAddAllCriticals</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#addAll(myAdapter.HCollection)"><code>ListAdapter.addAll(HCollection)</code></a> , <a href="../myAdapter/ListAdapter.html#addAll(int,myAdapter.HCollection)"><code>ListAdapter.addAll(int, HCollection)</code></a> methods in critical
 situations</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testAddCriticals()">testAddCriticals</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#add(java.lang.Object)"><code>ListAdapter.add(Object)</code></a> , <a href="../myAdapter/ListAdapter.html#add(int,java.lang.Object)"><code>ListAdapter.add(int, Object)</code></a> methods in critical
 situations</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testBacking()">testBacking</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#subList(int,int)"><code>ListAdapter.subList(int, int)</code></a> method</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testBacking2()">testBacking2</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#addAll(myAdapter.HCollection)"><code>ListAdapter.addAll(HCollection)</code></a> <a href="../myAdapter/ListAdapter.html#addAll(int,myAdapter.HCollection)"><code>ListAdapter.addAll(int, HCollection)</code></a>,
 <a href="../myAdapter/ListAdapter.html#removeAll(myAdapter.HCollection)"><code>ListAdapter.removeAll(HCollection)</code></a>, <a href="../myAdapter/ListAdapter.html#retainAll(myAdapter.HCollection)"><code>ListAdapter.retainAll(HCollection)</code></a> methods on sublist</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testClear()">testClear</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#clear()"><code>ListAdapter.clear()</code></a> method</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testConstructorWithParameters()">testConstructorWithParameters</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the constructor with parameter of the ListAdapter class</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testContains()">testContains</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#contains(java.lang.Object)"><code>ListAdapter.contains(Object)</code></a></div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testContainsAll()">testContainsAll</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#containsAll(myAdapter.HCollection)"><code>ListAdapter.containsAll(HCollection)</code></a></div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testDeepRecursiveSublist()">testDeepRecursiveSublist</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#add(java.lang.Object)"><code>ListAdapter.add(Object)</code></a>, <a href="../myAdapter/ListAdapter.html#add(int,java.lang.Object)"><code>ListAdapter.add(int, Object)</code></a>, <a href="../myAdapter/ListAdapter.html#remove(java.lang.Object)"><code>ListAdapter.remove(Object)</code></a>,
 <a href="../myAdapter/ListAdapter.html#remove(int)"><code>ListAdapter.remove(int)</code></a> method invoked on a sublist of a sublist</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testDefaultConstructor()">testDefaultConstructor</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the default constructor of the ListAdapter class</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testEquals()">testEquals</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#equals(java.lang.Object)"><code>ListAdapter.equals(Object)</code></a></div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testGet()">testGet</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#get(int)"><code>ListAdapter.get(int)</code></a></div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testHashCode()">testHashCode</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#hashCode()"><code>ListAdapter.hashCode()</code></a></div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testIndexOf()">testIndexOf</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#indexOf(java.lang.Object)"><code>ListAdapter.indexOf(Object)</code></a></div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testIsEmpty()">testIsEmpty</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#isEmpty()"><code>ListAdapter.isEmpty()</code></a></div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testIterator()">testIterator</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <code>ListAdapter.Iterator</code> class</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testIteratorExceptions()">testIteratorExceptions</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <code>ListAdapter.Iterator</code> class when Exceptions are thrown</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testLastIndexOf()">testLastIndexOf</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#lastIndexOf(java.lang.Object)"><code>ListAdapter.lastIndexOf(Object)</code></a></div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testListIterator()">testListIterator</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <code>ListAdapter.ListIterator</code> class</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testListIteratorExceptions()">testListIteratorExceptions</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <code>ListAdapter.ListIterator</code> class when exceptions are thrown</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testListIteratorExceptions2()">testListIteratorExceptions2</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <code>ListAdapter.ListIterator</code> class when exceptions are thrown</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testRecursiveSublist()">testRecursiveSublist</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#subList(int,int)"><code>ListAdapter.subList(int, int)</code></a> method invoked on another sublist</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testRemoveAll()">testRemoveAll</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#removeAll(myAdapter.HCollection)"><code>ListAdapter.removeAll(HCollection)</code></a></div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testRemoveIndex()">testRemoveIndex</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#remove(int)"><code>ListAdapter.remove(int)</code></a></div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testRemoveObject()">testRemoveObject</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#remove(java.lang.Object)"><code>ListAdapter.remove(Object)</code></a></div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testRetainAll()">testRetainAll</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#retainAll(myAdapter.HCollection)"><code>ListAdapter.retainAll(HCollection)</code></a></div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testSet()">testSet</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#set(int,java.lang.Object)"><code>ListAdapter.set(int, Object)</code></a></div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testSize()">testSize</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#size()"><code>ListAdapter.size()</code></a></div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testSublistsIndexing()">testSublistsIndexing</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#indexOf(java.lang.Object)"><code>ListAdapter.indexOf(Object)</code></a> <a href="../myAdapter/ListAdapter.html#lastIndexOf(java.lang.Object)"><code>ListAdapter.lastIndexOf(Object)</code></a>,
 <a href="../myAdapter/ListAdapter.html#add(int,java.lang.Object)"><code>ListAdapter.add(int, Object)</code></a>, <a href="../myAdapter/ListAdapter.html#remove(int)"><code>ListAdapter.remove(int)</code></a>, <a href="../myAdapter/ListAdapter.html#set(int,java.lang.Object)"><code>ListAdapter.set(int, Object)</code></a>
 methods on sublist</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testToArray()">testToArray</a></span>()</code></th>
<td class="colLast">
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#toArray()"><code>ListAdapter.toArray()</code></a> method</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#testToArrayWithParameters()">testToArrayWithParameters</a></span>()</code></th>
<td class="colLast">
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#toArray(java.lang.Object%5B%5D)"><code>ListAdapter.toArray(Object[])</code></a></div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>TestList</h4>
<pre>public&nbsp;TestList()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="setup()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setup</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setup()</pre>
</li>
</ul>
<a id="cleanup()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cleanup</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;cleanup()</pre>
</li>
</ul>
<a id="testBacking()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testBacking</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testBacking()</pre>
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#subList(int,int)"><code>ListAdapter.subList(int, int)</code></a> method
 <p>

 <br><br>Summary:                                Testing the sublist() method and how the father list changes after having invoked different methods
 <br><br>Description:                    a sublist is created, some list's methods are invoked on it to check if the father lists correctly
                                                                        backs the changes on the son
 <br><br>Design test:                            filling an empty list and creating a sublist from index 0 to half of the father list. Adding and removing
                                                                        an item from it and checking that the father size and elements change in the same way as the son.
                                                                        Cleaning the sublist content and seing that the father list content is affected by this change
 <br><br>Preconditions:                  add(), remove(), clean() should be correctly implemented for lists
 <br><br>Postconditions:                         the father list must be affected by all the changes applied to the son list
 <br><br>Expected results:               an item should be added and removed from both lists, their sizes must be increased and then decreased, when
                                                                        the sublist is cleaned the elements must also be deleted from the father list</div>
</li>
</ul>
<a id="testBacking2()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testBacking2</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testBacking2()</pre>
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#addAll(myAdapter.HCollection)"><code>ListAdapter.addAll(HCollection)</code></a> <a href="../myAdapter/ListAdapter.html#addAll(int,myAdapter.HCollection)"><code>ListAdapter.addAll(int, HCollection)</code></a>,
 <a href="../myAdapter/ListAdapter.html#removeAll(myAdapter.HCollection)"><code>ListAdapter.removeAll(HCollection)</code></a>, <a href="../myAdapter/ListAdapter.html#retainAll(myAdapter.HCollection)"><code>ListAdapter.retainAll(HCollection)</code></a> methods on sublist
 <p>

 <br><br>Summary:                                Testing the sublists' methods to add, remove, and retain collections and how the father list
                                                                        backs the changes on the son
 <br><br>Description:                    an empty sublis is created, some list's methods that use collections are invoked on it to check if the
                                                                        father list correctly backs the changes on the son
 <br><br>Design test:                            creating an empty sublist of the pre-filled list in the middle of this one. Using addAll() and removeAll()
                                                                        methods to insert and remove the content of another list, it is checked that the son and father lists are
                                                                        correctly modified through the size() method and by printing their content. Then the elements previously
                                                                        added and removed are now added again, with one new element not in the parameter collection, and retained on
                                                                        the sublist, it's verified that the elements contained in the father list are not affected by the retain on the
                                                                        sublist
 <br><br>Preconditions:                  add(), size() and iterators should be correctly implemented for lists
 <br><br>Postconditions:                         the father list must be affected by all the changes applied to the son list, when retainAll() is invoked
                                                                        the elements in the father list out of sublist index don't have to be modified
 <br><br>Expected results:               a collection should be added to the sublist and the father list should be modified too, then it should be
                                                                        removed and added again with also one more element and only the element contained in the collection should be
                                                                        retained in the sublist, in the father the elements out of the sublist shouldn't be affected by this last
                                                                        invokation</div>
</li>
</ul>
<a id="testSublistsIndexing()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testSublistsIndexing</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testSublistsIndexing()</pre>
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#indexOf(java.lang.Object)"><code>ListAdapter.indexOf(Object)</code></a> <a href="../myAdapter/ListAdapter.html#lastIndexOf(java.lang.Object)"><code>ListAdapter.lastIndexOf(Object)</code></a>,
 <a href="../myAdapter/ListAdapter.html#add(int,java.lang.Object)"><code>ListAdapter.add(int, Object)</code></a>, <a href="../myAdapter/ListAdapter.html#remove(int)"><code>ListAdapter.remove(int)</code></a>, <a href="../myAdapter/ListAdapter.html#set(int,java.lang.Object)"><code>ListAdapter.set(int, Object)</code></a>
 methods on sublist 
 <p>
                                                                        ATTENTION: in the test case documentation is not considered the situation in which the sublist goes from index
                                                                        0 to index size() of the father list. In this situation the test still works but the indexes if the list and sublist
                                                                        ar exactly the same
 <br><br>Summary:                                Testing how the methods that require an index modify the father list and the sublist after an invokation
                                                                        on one of those
 <br><br>Description:                    a sublist of the pre-filled list is created, checking that indexOf() and lastIndexOf() return a different
                                                                        value if invoked on the list or sublist even if the searched element is the same, using add(), remove() and set()
                                                                        at a fixed index and checked that the father list is modified ad the right index
 <br><br>Design test:                            creating a sublist of the pre-filled one, invoking indexOf() and lastIndexOf() on both lists and checking that
                                                                        the returned index is different even if the element passed is the same. Invoking add(), remove() and set() on
                                                                        the sublist ad a fixed index and checking if the main list is modified at the right index
 <br><br>Preconditions:                  sublist() and iterator must be correctly implemented
 <br><br>Postconditions:                         the index returned by indexOf() and lastIndexOf must be different and based on where the list starts even if
                                                                        the object requested to the lists is the same. When invoked add(), remove(), set() at specified index in the sublist
                                                                        the father list must be modified at his relative index
 <br><br>Expected results:               two different indexes should be returned from the invokation of indexOf() and lastIndexOf() on both list and sublist
                                                                        when invoked the other methods the father list should be modified at an index which is different from the index
                                                                        passed to the method of the sublist.</div>
</li>
</ul>
<a id="testRecursiveSublist()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testRecursiveSublist</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testRecursiveSublist()</pre>
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#subList(int,int)"><code>ListAdapter.subList(int, int)</code></a> method invoked on another sublist
 <p>

 <br><br>Summary:                                Testing the sublist() method when invoked on a sublist
 <br><br>Description:                    a list is filled with elements, then the sublist(int, int) method is invoked at first on the list and then
                                                                        on the sublist obtained from the previous invocation and so on until the sublist size is 0
 <br><br>Design test:                            filling an empty list and creating a sublist from index 1 to size()-1 of the father list. 
                                                                        Doing the same exact thing on the sublist obtained from the previous iteration and checking that the current
                                                                        sublist is of the correct size and the printing through iterator is correct
 <br><br>Preconditions:                  add() and size() should be correctly implemented
 <br><br>Postconditions:                         the sublist's size must be decreased by two units at every iteration
 <br><br>Expected results:               after every iteration the sublist's size should be decreased by two units, compared to the father size(), and
                                                                        the elements printed should be the same as the parent but without the first and last element</div>
</li>
</ul>
<a id="testDeepRecursiveSublist()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testDeepRecursiveSublist</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testDeepRecursiveSublist()</pre>
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#add(java.lang.Object)"><code>ListAdapter.add(Object)</code></a>, <a href="../myAdapter/ListAdapter.html#add(int,java.lang.Object)"><code>ListAdapter.add(int, Object)</code></a>, <a href="../myAdapter/ListAdapter.html#remove(java.lang.Object)"><code>ListAdapter.remove(Object)</code></a>,
 <a href="../myAdapter/ListAdapter.html#remove(int)"><code>ListAdapter.remove(int)</code></a> method invoked on a sublist of a sublist
 <p>

 <br><br>Summary:                                Testing add() and remove() methods invoked on a sublist of a sublist
 <br><br>Description:                    a sublist of the main list is created, then a sublist of the other one is created, add() and remove() methods
                                                                        are invoked on the deeper one. Verified that the main list and the higher sublist are correclty modified
 <br><br>Design test:                            invoking the sublist() method on the pre-filled list from indx 1 to size()-1, then the same exact method is invokated
                                                                        on the sublist, in order to have a sublist of the sublist. It is added an element to the deepest sublist and it
                                                                        is verified that the fathers are correctly modified, this happens for both add() and remove() methods with and
                                                                        without index as a parameter
 <br><br>Preconditions:                  sublist() and iterators should be correctly implemented
 <br><br>Postconditions:                         in all the three lists an item must be insert, than deleted, than insert again ad a specified index, and at the
                                                                        and deleted again, their sizes must correctly increase and decrease  
 <br><br>Expected results:               after the first add a null object should be insert in all the lists and their sizes should increase by one, then
                                                                        the element should be removed and the sizes decreased. This exact behaviour is expected also with the add() and
                                                                        remove() methods with a specified index</div>
</li>
</ul>
<a id="testIterator()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testIterator</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testIterator()</pre>
<div class="block">Test the <code>ListAdapter.Iterator</code> class
 <p>

 <br><br>Summary:                                Testing all methods of the Iterator class
 <br><br>Description:                    an iterator on a list is created, the list is printed and cleaned through the iterator
 <br><br>Design test:                            creating the iterator on the pre-filled list, scanning the list with the hasNext() method and printing the elements
                                                                        with next(), the correct order of the elements is checked using the toArray() method of the list.
                                                                        Then creating a new iterator and deleting the content of the list using the hasNext() and next() methods
                                                                        to scan it and delete() method to delete the current element
 <br><br>Preconditions:                  toArray() and size() should be correctly implemented
 <br><br>Postconditions:                         the next() method should return the element after the current position of the iterator, hasNext() must return fals
                                                                        only if the iterator is at the end of the list, true otherwise, remove() must delete the element that has been returned
                                                                        by the previous next() call.
 <br><br>Expected results:               after the first cycle the entire content of the list should be printed, after the second one the list should
                                                                        be empty.</div>
</li>
</ul>
<a id="testIteratorExceptions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testIteratorExceptions</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testIteratorExceptions()</pre>
<div class="block">Test the <code>ListAdapter.Iterator</code> class when Exceptions are thrown
 <p>

 <br><br>Summary:                                Testing methods of the Iterator class when they should throw an exception
 <br><br>Description:                    an iterator on a list is created, iterated until the end of the list and tried to call next() then tried to
                                                                        use delete() twice in a row
 <br><br>Design test:                            creating the iterator on the pre-filled list, scanning the list with the hasNext() method and calling next() 
                                                                        method when the iterator is already at the end of the list, then trying to call twice in a row the delete()
                                                                        method
 <br><br>Preconditions:                  
 <br><br>Postconditions:                         after calling the last next() an error must be thrown, after calling the second remove() and error must be
                                                                        thrown too
 <br><br>Expected results:               NoSuchElementException should be thrown after calling next() while iterator is at the end of the list, IllegalStateException
                                                                        should be thrown when remove() is called twice in a row</div>
</li>
</ul>
<a id="testListIterator()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testListIterator</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testListIterator()</pre>
<div class="block">Test the <code>ListAdapter.ListIterator</code> class
 <p>

 <br><br>Summary:                                Testing methods of the ListIterator class 
 <br><br>Description:                    a listiterator on a list is created, iterated until the end of the list and then iterated back to the beginning
                                                                        printing the list backwards. a listiterator is created in the middel of the list and an element is added there
                                                                        then another listiterator is created to set the entire list at null objects. a last iterator is created to clean
                                                                                the content of the list
 <br><br>Design test:                            creating the iterator on the pre-filled list, scanning the list with the hasNext() method until the end of it and
                                                                        printing it backwards with hasPrevious() and previous() methods. creating a listiterator in the middle of the list
                                                                        and invoking add() to insert a null object there, then setting all the elements of the list at null and cleaning
                                                                        it still through iterators.
 <br><br>Preconditions:                  toArray(), size() and isEmpty() methods of ListAdapter must be well implemented
 <br><br>Postconditions:                         the first iterator must travell to the end of the list and then print it backwards, previous() must return the element
                                                                        placed before the iterator. the second iterator must add an element in the position before it. the next one must travel
                                                                        to the end of the list and set all the elements at null. the last one must travell to the end of the list too and delete
                                                                        all the elements.
 <br><br>Expected results:               after the first iteration the list should be printed backwards, then an element should be added in the middle of the list
                                                                        and the list size should increase, after this the iterator should put at null all the elements and at the end the list
                                                                        should be cleaned.</div>
</li>
</ul>
<a id="testListIteratorExceptions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testListIteratorExceptions</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testListIteratorExceptions()</pre>
<div class="block">Test the <code>ListAdapter.ListIterator</code> class when exceptions are thrown
 <p>

 <br><br>Summary:                                Testing methods of the ListIterator class that navigate the list and throw Exceptions
 <br><br>Description:                    trying to create a listiterator starting at illegal indexes, then an iterator is created at the beggining of the
                                                                        list and previous() method is called, another iterator is created at the end of the list and next() is called
 <br><br>Design test:                            trying to create an iterator at a negative index, then trying to do the same at an index bigger than the list size
                                                                        creating an iterator at the begginning of the list and invoking previous() than doing the same at the end of the list
                                                                        with next()
 <br><br>Preconditions:                  size() method of ListAdapter must be well implemented
 <br><br>Postconditions:                         all the four iterations must throw an exception
 <br><br>Expected results:               the two constructors should throw IndexOutOfBoundException than the two other iterations should throw NoSuchElementException</div>
</li>
</ul>
<a id="testListIteratorExceptions2()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testListIteratorExceptions2</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testListIteratorExceptions2()</pre>
<div class="block">Test the <code>ListAdapter.ListIterator</code> class when exceptions are thrown
 <p>

 <br><br>Summary:                                Testing methods of the ListIterator class that modify the list and throw Exceptions
 <br><br>Description:                    creating an iterator and trying to modify the list without any further iteration, then calling two times the methods
                                                                        that modify the list without any iteration between them
 <br><br>Design test:                            creating an iterator and calling remove() and set() methods without any previous iteration. calling add() and then
                                                                        invoking set() and remove() without any iteration in between. calling remove() and the invoking again set() and remove()
                                                                        without any iteration in between
 <br><br>Preconditions:                  
 <br><br>Postconditions:                         all the methods must throw an exception
 <br><br>Expected results:               all the methods invokated that modify the list should throw IllegalStateException</div>
</li>
</ul>
<a id="testDefaultConstructor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testDefaultConstructor</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testDefaultConstructor()</pre>
<div class="block">Test the default constructor of the ListAdapter class
 <p>

 <br><br>Summary:                        test to verify the correct creation of an object of type ListAdapter
 <br><br>Design test:            invoking the default costructor and checking if an empty object is created
 <br><br>Preconditions:          the size() method works correctly
 <br><br>Postconditions:                 the created object must be empty
 <br><br>Expected results:       the size of the created object is zero</div>
</li>
</ul>
<a id="testConstructorWithParameters()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testConstructorWithParameters</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testConstructorWithParameters()</pre>
<div class="block">Test the constructor with parameter of the ListAdapter class
 <p>

 <br><br>Summary:                        test to verify the correct creation of an object of type ListAdapter
                                                                that contains the same values as the collection passed as a parameter
 <br><br>Design test:            using a pre-filled List, the constructor is invoked passing the collection containing
                                                                the elements as a parameter and the respective arrays obtained with toArray() are compared. 
                                                                Then testing the case a null object is passed
 <br><br>Preconditions:          The toArray () method must be working correctly
 <br>                                                        Iterators must be working correctly
 <br><br>Postconditions:                 the created object must be the same as the object passed as a parameter, the constructor with
                                                                a null pointer as a parameter should throw NUllPointerException.
 <br><br>Expected results:       the same elements of the test collection must be present in the main test collection. When passed 
                                                                a null collection NullPointerException should be thrown</div>
</li>
</ul>
<a id="testAdd()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testAdd</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testAdd()</pre>
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#add(java.lang.Object)"><code>ListAdapter.add(Object)</code></a> , <a href="../myAdapter/ListAdapter.html#add(int,java.lang.Object)"><code>ListAdapter.add(int, Object)</code></a> methods
 <p>

 <br><br>Summary:                        test to verify the correct execution of the add() methods
 <br><br>Design test:            adding to the empty list the same elements contained in the pre-filled list in the same order,
                                                                checking if toArray() and size() invoked on both lists return the same results then printing the array
                                                                obtained the list that has been modified. Adding another element at the previous list at a fixed position
                                                                and checking if the list has been correclty updated through size() and toArray(), than printing the result
 <br><br>Preconditions:          toArray() and size() must be working correctly
 <br><br>Postconditions:                 the obtained array from the modified should contain the same objects in the same order as stored in the array
                                                                obtained from the pre-filled list, then an item should be added to the first at a fixed index
 <br><br>Expected results:       at first the arrays obtained from the two lists must be equals, then the modified one should have one more
                                                                element at a fixed position</div>
</li>
</ul>
<a id="testAddAll()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testAddAll</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testAddAll()</pre>
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#addAll(myAdapter.HCollection)"><code>ListAdapter.addAll(HCollection)</code></a> , <a href="../myAdapter/ListAdapter.html#addAll(int,myAdapter.HCollection)"><code>ListAdapter.addAll(int, HCollection)</code></a> methods
 <p>

 <br><br>Summary:                        test to verify the correct execution of the addAll() methods
 <br><br>Design test:            adding to the empty list the the pre-filled list and checking if they're equals with the equals() method,
                                                                also checking if the size has been correctly updated.
                                                                Then adding another list to the previous one at a fixed index and checking that the parameters have been
                                                                correctly updated
 <br><br>Preconditions:          equals(), size() and iterators must be working correctly
 <br><br>Postconditions:                 after the first addAll() the modified list should contain the same elements as the pre-filled one,
                                                                then the former should have two more elements inserted at a fixed index.
 <br><br>Expected results:       the two lists must be equals after the method is invoked the first tome, then the modified one should have
                                                                some more elements inserted at a fixed index</div>
</li>
</ul>
<a id="testAddCriticals()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testAddCriticals</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testAddCriticals()</pre>
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#add(java.lang.Object)"><code>ListAdapter.add(Object)</code></a> , <a href="../myAdapter/ListAdapter.html#add(int,java.lang.Object)"><code>ListAdapter.add(int, Object)</code></a> methods in critical
 situations
 <p>

 <br><br>Summary:                        Test that add(Object) and add(int,Object) works fine with a null object and throws an exception when the index
                                                                is out of bounds
 <br><br>Design test:            passing null to both add() methods and checking that everything works, passing illegal indexes and seeing if
                                                                the method throws the expected exceptions
 <br><br>Postconditions:                 null should be added do the list in both cases, when using indexes out of bound IndexOutOfBoundException should
                                                                be thrown
 <br><br>Expected results:       the list must have a null element at the specified index and at last index, the other methods should
                                                                throw IndexOutOfBOundException</div>
</li>
</ul>
<a id="testAddAllCriticals()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testAddAllCriticals</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testAddAllCriticals()</pre>
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#addAll(myAdapter.HCollection)"><code>ListAdapter.addAll(HCollection)</code></a> , <a href="../myAdapter/ListAdapter.html#addAll(int,myAdapter.HCollection)"><code>ListAdapter.addAll(int, HCollection)</code></a> methods in critical
 situations
 <p>

 <br><br>Summary:                                Testing that addAll(Hcollection) and addAll(int, HCollection) throw the right exceptions
 <br><br>Design test:                            passing a null collection to addAll() with valid indexes, then passing a valid HCollection but with invalid
                                                                        indexes
 <br><br>Preconditions:
 <br><br>Postconditions:                         first two cases should throw NullPointerException, the last two should throw IndexOutOfBoundException
 <br><br>Expected results:               all test cases should throw exceptions, nothing should change in the list</div>
</li>
</ul>
<a id="testClear()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testClear</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testClear()</pre>
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#clear()"><code>ListAdapter.clear()</code></a> method
 <p>

 <br><br>Summary:                        Verify that the method makes the list empty
 <br><br>Design test:                    printing initial size and elements of the list, invoking clear on that list, verify that it makes the list of
                                                                size 0 and empty
 <br><br>Preconditions:          the iterators and size() are implemented correctly
 <br><br>Postconditions:                 after the call size() should return 0 and iterate() method should print an empty list
 <br><br>Expected results:       size of the list must be 0 and and empty list must be printed</div>
</li>
</ul>
<a id="testContains()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testContains</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testContains()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#contains(java.lang.Object)"><code>ListAdapter.contains(Object)</code></a>
 <p>        
 <br><br>Summary:                                Verifies that the method returns true if and only if the container contains the specified element
 <br><br>Design test:                    using a pre-filled list, verification of the existence of an element present, verification of the existence
                                                                        of an element not present. Check with an instance of an object and a null.
 <br><br>Description:                    adding a null object to the list, printing the liste elements for a better visualisation of che collection,
                                                                        Verify that the method returns true using one of the elements printed as a parameter, false using an element
                                                                        that does not exist in the collection as a parameter, then checking if null is considered a valid parameter
 <br><br>Preconditions:                  the add(Object) method is correctly implemented
 <br><br>Postconditions:                         the method must return true if the element passed is actually contained, false otherwise, it should accept a null object
 <br><br>Expected results:               true with already presente data and null object, false with data not present</div>
</li>
</ul>
<a id="testContainsAll()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testContainsAll</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testContainsAll()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#containsAll(myAdapter.HCollection)"><code>ListAdapter.containsAll(HCollection)</code></a>
 <p>
 <br><br>Summary:                                        the test verifies that the main collection contains all the elements of the collection passed as a parameter
 <br><br>Design test:                            created a new list with elements of the pre-filled one, added some new elements to the latter and verificated that
                                                                                one contains the other but not vice versa, tested the case of a null parameter
 <br><br>Description:                                    a new list is created using the pre-filled list, some elements are added to the pre-filled list, is verified
                                                                                that the methos returns true if the method is invoked on the just created list if the parameter is the pre-filled list, but if invoked
                                                                                vice versa the method returns false, passed a null collection to the method and verified that throws an exception
 <br><br>Preconditions:                          The add(Object) method must be correctly implemented
 <br><br>Postconditions:                                 the method must return true if the collection contains all the elements present in the collection passed as a parameter
                                                                                and throw an exception when a null collection is passed 
 <br><br>Expected results:                       If the list contains all the elements contained in the parameter true is returned, if the collection is null
                                                                                NUllPointerException is thrown</div>
</li>
</ul>
<a id="testEquals()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testEquals</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testEquals()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#equals(java.lang.Object)"><code>ListAdapter.equals(Object)</code></a>
 <p>
 <br><br>Summary:                                        the equals method must return true only if the two collections contain the same elments and in the same order 
 <br><br>Design test:                            the empty list is filled with the same elements of the pre-filled list.
                                                                                the reflective property is tested for equal lists, non-equal lists are compared and the case with a non-collection object is tested
 <br><br>Description:                            after the fill of the second list with the same elements contained in the first one they're compared.
                                                                                then an element is added to one of them and they're compared again. the list is cleared and re-filled with the same elements as the other list
                                                                                but in a different order and they're compared again. it's also tested the case a non-collection object is passed as a parameter
 <br><br>Preconditions:                          the add(Object) and clear() methods must be correctly implemented
 <br><br>Postconditions:                                 the method must return true if the two containers have the same elements arranged in the same order and must return false
                                                                                if the two objects are incompatible for a comparison
 <br><br>Expected results:                       true only in the first case described and false for the others</div>
</li>
</ul>
<a id="testGet()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testGet</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testGet()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#get(int)"><code>ListAdapter.get(int)</code></a>
 <p>
 <br><br>Summary:                                test to verify the correct return parameter of the get function
 <br><br>Design test:                    in the pre-filled list check that each element is reachable thorough its index, testing also the case an
                                                                        illegal index is passed
 <br><br>Description:                    the list is printed to display it's content, a for loop is called to verify that each element is correctly returned
                                                                        by the get method, then two illegal indexes are passed to see the method behaviour
 <br><br>Preconditions:                  iterators and toArray() method are correctly implemented
 <br><br>Postconditions:                         the element returned must be the one contained in the i-th position of the list, and index too big or to small
                                                                        should make the method throw in exception
 <br><br>Expected results:               the for loop ends correctly and prints the content of the list, the illegal indexes should make the method
                                                                        throw IndexOutOfBoundException</div>
</li>
</ul>
<a id="testHashCode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testHashCode</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testHashCode()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#hashCode()"><code>ListAdapter.hashCode()</code></a>
 <p>
 <br><br>Summary:                                Test the hashcode method
 <br><br>Design test:                    is tested the case of an empty list, than the same elements of the pre-filled list are added to the empty one and this case
                                                                        is tested, at last the order of the elements are changed and so should be the hashcode
 <br><br>Description:                    after having entered the data contained in the pre-filled list in the empty list the calculated hash must be the same.
                                                                        the hash calculation of the list in which has been changed the order must be different
 <br><br>Preconditions:                  the hash calculation must be the one described in HList, add(Object) method must work correctly
 <br><br>Postconditions:                 only if the compared objects have the same elements arranged in the same order, the hash must be identical
 <br><br>Expected results:               the cases in which the hash of the two objects match is exactly when the content and order of the elements of the
                                                                        two objects are the same</div>
</li>
</ul>
<a id="testIndexOf()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testIndexOf</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testIndexOf()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#indexOf(java.lang.Object)"><code>ListAdapter.indexOf(Object)</code></a>
 <p>
 <br><br>Summary:                                                Test for the method that looks for the position of the first element corresponding to the element passed as a parameter
 <br><br>Design test:                            looking for a non-existing element, an existing element, a duplicated element, a null elemente. Search also with empty
                                                                                list
 <br><br>Description:                            at first looking for a non-existing element, than for an existing one. duplicating that element and looking for it again,
                                                                                testing a null object and than testing on a void and a null list.
 <br><br>Preconditions:                          the list object must not be null (but can be empty)
 <br><br>Postconditions:                                 the index of the first matching element found is returned, otherwise -1
 <br><br>Expected results:                       -1 for empty list and element not found; index of the position of the single element, searched; index of the position of the
                                                                                first element of the list found. NullPointerException for a null list.</div>
</li>
</ul>
<a id="testIsEmpty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testIsEmpty</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testIsEmpty()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#isEmpty()"><code>ListAdapter.isEmpty()</code></a>
 <p>
 <br><br>Summary:                                Testing the method isEmpty()
 <br><br>Design test:                    testing on an empty list, then adding an element and testing it again, the list is cleared and the method called
                                                                        another time
 <br><br>Description:                    at first it's invoked on an empty list, after adding a data item it is verified that the container is not indicated
                                                                        as empty, then after the clearing it is verified that the container is correctly considered empty
 <br><br>Preconditions:                  the add(Object) and clear() methods must be properly implemented and working
 <br><br>Postconditions:                         the method must return true if the container is empty and therefore does not contain any elements
 <br><br>Expected results:               false after insert, true at first and after the cleaning</div>
</li>
</ul>
<a id="testLastIndexOf()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testLastIndexOf</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testLastIndexOf()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#lastIndexOf(java.lang.Object)"><code>ListAdapter.lastIndexOf(Object)</code></a>
 <p>
 <br><br>Summary:                                Test for the method that looks for the position of the last element corresponding to the element passed as a parameter
 <br><br>Design test:                    looking for a non-existing element, an existing element, a duplicated element, a null elemente. Search also with empty
                                                                        list
 <br><br>Description:                    at first looking for a non-existing element, than for an existing one. duplicating that element and looking for it again,
                                                                        adding two null objects and testing that situation and than testing on a void and a null list.
 <br><br>Preconditions:                  the list object must not be null (but can be empty)
 <br><br>Postconditions:                         the index of the last matching element found is returned, otherwise -1
 <br><br>Expected results:               -1 for empty list and element not found; index of the position of the single element, searched; index of the position of the
                                                                        last element of the list found. NullPointerException for a null list.</div>
</li>
</ul>
<a id="testRemoveObject()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testRemoveObject</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testRemoveObject()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#remove(java.lang.Object)"><code>ListAdapter.remove(Object)</code></a>
 <p>
 <br><br>Summary:                                        Verifies that the tested method removes the specified element or returns false if it is not present
 <br><br>Description:                            both with empty collection and with non-existent element, the tested method is invoked verifying that it returns
                                                                                the expected result.
 <br><br>Design test:                            removing an existing element and checkin if the parameters are correctly modified, removing a non-existing element from
                                                                                the list then deleting the same element from the empty list, added and removed a null object from the list
 <br><br>Preconditions:                          the add(Object obj) method and the iterators method must be correctly implemented
 <br><br>Postconditions:                                 after invoking the method, the collection must not contain the data entered as a parameter, returning true,
                                                                                if the collection is not modified it returns false
 <br><br>Expected results:                       after the removal of the specified element, the size of the collection must be decreased by one unit,
                                                                                the first element corresponding to the entered parameter must have been removed and true must be returned, with data not present,
                                                                                however, false</div>
</li>
</ul>
<a id="testRemoveIndex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testRemoveIndex</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testRemoveIndex()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#remove(int)"><code>ListAdapter.remove(int)</code></a>
 <p>
 <br><br>Summary:                                                Verifies that the tested method removes and returns the element at the specified index
 <br><br>Description:                            both with empty collection and with non-existent element, the tested method is invoked verifying that it returns
                                                                                the expected result.
 <br><br>Design test:                            removing all the elements in a list and printing it in the correct order, while the list is empty the method is invoked
                                                                                again with an index too small and one too big
 <br><br>Preconditions:                          the get(int) method and the iterators method must be correctly implemented
 <br><br>Postconditions:                                 after invoking the method, the collection must not contain the data at the specified index, returning the remove element,
 <br><br>Expected results:                       after the removal of the specified index, the relvative element must be returned and the size must be decreased by one
                                                                                if the index is out of bounds an error should be thrown</div>
</li>
</ul>
<a id="testRemoveAll()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testRemoveAll</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testRemoveAll()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#removeAll(myAdapter.HCollection)"><code>ListAdapter.removeAll(HCollection)</code></a>
 <p>
 <br><br>Summary:                                        the method that removes all the elements contained in the collection passed as parameter from the main collection is tested
 <br><br>Description:                                    tested the situation in which a null collection is passed, after verification of correct operation using empty collection,
                                                                                some elements of the pre-filled collection are added to the prameter one and another element not present. After checking that the returned
                                                                                value is true, the same exact method is called again in now it returns false. In the pre-filled list a duplicated element is added to see
                                                                                if the method removes all the instances of a specified element.
 <br><br>Design test:                            check that if a null collection is passed an exception is thrown, see that an empty collection doesn't modify the list,
                                                                                see if the collection contains some elements of the list the method returns true and it deletes all the instances of an object and then testing
                                                                                that the method returns false if the list doesn't contain any of the elems in the collection.
 <br><br> Preconditions:                                 The add(Object) and toArray() methods must be correctly implemented
 <br><br>Postconditions:                                 in the main collection there must be no elements contained in the collection passed as a parameter, an exception should be
                                                                                thrown in the case of a null collection as a parameter
 <br><br>Expected results:                       false if an empty collection is passed or if the collection doesn't contain any element of the list,
                                                                                true if at least one element is removed</div>
</li>
</ul>
<a id="testRetainAll()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testRetainAll</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testRetainAll()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#retainAll(myAdapter.HCollection)"><code>ListAdapter.retainAll(HCollection)</code></a>
 <p>
 <br><br>Summary:                                        the method that retains all the elements contained in the collection passed as parameter from the main collection is tested
 <br><br>Description:                            tested the situation in which a null collection is passed, verificating that if the same exact collection is passe ad a
                                                                                parameter nothing is modified, than testing when the parameter collection contains some of the main list elements and one that is not contained,
                                                                                testing the case of an empty list.
 <br><br>Design test:                            check that if a null collection is passed an exception is thrown, see that if the parameter has the same elements of the 
                                                                                main list that doesn't modify this, see if the collection contains some elements of the list the method returns true and it retains all the
                                                                                instances of an object and then testing that the list gets cleared when an empty list is passed.
 <br><br> Preconditions:                                 The add(Object), toArray() and isEmpty() methods must be correctly implemented
 <br><br>Postconditions:                                 in the main collection there must all the elements contained in the collection passed as a parameter, an exception should be
                                                                                thrown in the case of a null collection as a parameter
 <br><br>Expected results:                       false only if the parameter collection is equals to the main collection, an exception should be thrown if a null coll
 is passed</div>
</li>
</ul>
<a id="testSet()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testSet</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testSet()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#set(int,java.lang.Object)"><code>ListAdapter.set(int, Object)</code></a>
 <p>
 <br><br>Summary:                                        The method must correctly set all elements of the list and return the substituted element
 <br><br>Description:                            an object and a null object are insert in the pre-filled list and the correctness of the insertion is checked controlling
                                                                                that the element in the array returned by the toArray() method matches the object past to the method, the same thing, using the array obtained
                                                                        calling toArray() before the set(Object) method, is done to check if the previously contained element is correclty returned. Is also tested the
                                                                                Exceptions throwing in case of an illegal index
 <br><br>Design test:                            after the invocation  of set method the list must contain a different element at the specified index and the previously
                                                                                contained one must be returned, this situation is also tested with a null object. Then two illegal indexes are passed and en exception should
                                                                                be thrown. 
 <br><br>Preconditions:                          The implementation of the add(Object) and toArray() methods is correct
 <br><br>Postconditions:                         the main list is different than it was before the invocation of the set method and the previously contained element is
                                                                                returned ar every invocation
 <br><br>Expected results:                       the element in the obtained array of the list must matche the element set by the method and the returned object must
                                                                                match the element in the obtained array of the list at that index</div>
</li>
</ul>
<a id="testSize()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testSize</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testSize()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#size()"><code>ListAdapter.size()</code></a>
 <p>
 <br><br>Summary:                                        Method test that returns the current size of the Collection
 <br><br>Design test:                            test of the size of the collection before and after adding an element and its removal,
                                                                                increasing and decreasing the value of the size of the collection, then checking that it don't change after invoking set method. Tested the case
                                                                                of an empty list
 <br><br>Description:                            The size method is invoked after adding an element, after removing an element and after the set method. In order the size
                                                                                should increase, then decrease and at the end should not change. Tested that an empty list's size is 0
 <br><br>Preconditions:                          the add(), remove() and set() methods must be properly implemented
 <br><br>Postconditions:                                 the returned value must correspond to the number of elements contained in the collection
 <br><br>Expected results:                       0 if collection is empty, otherwise the number of elements present in the collection.
                                                                                The size of the collection must vary consistently as the insertion/removal elements vary</div>
</li>
</ul>
<a id="testToArray()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testToArray</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testToArray()</pre>
<div class="block">Test the <a href="../myAdapter/ListAdapter.html#toArray()"><code>ListAdapter.toArray()</code></a> method
 <p>

 <br><br>Summary:                                        test to verify the correct execution of the toArray() method
 <br><br>Design test:                            using a pre-filled List, toArray() is invoked on it, the obtained array is compared
                                                                                to the expected result and then is printed, through the iterator, the actual content of the list
 <br><br>Preconditions:                          Iterators must be working correctly
 <br><br>Postconditions:                                 the obtained array must contain the same objects in the same order as stored in the list 
 <br><br>Expected results:                       the array printed is exactly the same as the list printed with the iterator</div>
</li>
</ul>
<a id="testToArrayWithParameters()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>testToArrayWithParameters</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;testToArrayWithParameters()</pre>
<div class="block">Test of <a href="../myAdapter/ListAdapter.html#toArray(java.lang.Object%5B%5D)"><code>ListAdapter.toArray(Object[])</code></a>
 <p>
 <br><br>Summary:                                                comparable test with the toArray () method with the difference that, if it is large enough, the array passed as a parameter is used
 <br><br>Design Test:                                    invokation on an empty list and an array is passed as a parameter, some elements are inserted into the collection and an array with
                                                                                        of the same size is passed as a parameter,some elements are inserted into the collection and a partially occupied array with a smaller size is passed as a parameter.
                                                                                        Also test of the correct throw of the exception with null parameter
 <br><br>Description:                                            for all three situations indicated by the design test, it is verified with the use of a manually created array that the tested method returns an
                                                                                        array of Object, filled with null the greater the difference between the size of the array passed as parameter and the size of the collection, exactly the elements of the collection, or a new array always with the elements of the collection
 <br><br>Preconditions:                                  The add(Object) method must be correctly implemented
 <br><br>Postconditions:                                         the returned array must contain all the elements present in the collection on which the method is invoked and in the order with
 which they appear in the collection
 <br><br>Expected results:                               the method must return the array passed as a parameter with the objects of the collection, if large enough, otherwise
                                                                                        return another one with a size equal to the number of objects in the collection. If collection empty, the array supplied as a parameter is not
                                                                                        modified</div>
</li>
</ul>
<a id="iterate(myAdapter.HIterator)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>iterate</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;iterate&#8203;(<a href="../myAdapter/HIterator.html" title="interface in myAdapter">HIterator</a>&nbsp;iter)</pre>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
